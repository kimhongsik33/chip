## SpringBasic_Part2
## Chapter2-1. 스프링 MVC 흐름과 구성 컴포넌트

 #Spring MVC흐름
 
  1) client ------> Dispatcher Servlet // 요청을 수신
  
  2) Dispatcher Servlet -------> Handler Mapping // 컨트롤러 문의
  
  3) Dispatcher Servlet -------> Handler Adapter // 요청을 controller에게 전송
  
  4) Controller -------> Handler Adapter // 요청결과와 뷰에 대한 정보를 리턴한다.
  
  5) Handler Adapter --------> Dispatcher Servlet // Model And View 객체를 만들어서 전달
  
  6) Dispatcher Servlet --------> View Resolver // 응답할 View를 요청한다.
  
  7) Dispatcher Servlet --------> View // View를 이용해서 응답을 한다.  
  
  # Handler == Controller
  # Handler Mapping -----> Handler Adapter (일대일 매핑) 
  
  
## Chapter2-2. 스프링 MVC 프로젝트의 구조

## Chapter2-3. 컨트롤러 작성하기 및 한글 처리
 servlet-context.xml에서 <annotation-driven />가 없으면 어노테이션을 쓸 수가 없다.

 
## Chapter2-4. ModelAndView 객체를 이용한 컨트롤러 작성

 # 컨트롤러 제작 순서
 최초의 클라이언트 요청이 들어오면 컨트롤러로 진입을 한다.
 컨트롤러는 요청에 대한 작업처리를 한 후에 뷰에 데이터를 전달한다.
 
 1) @Controller를 이용한 클래스 생성
 2) @RequestMapping을 이용한 요청경로를 매핑 한다.
 3) 요청처리 메소드를 구현한다.
 4) 뷰 이름을 리턴한다.
 
 # ModelAndView객체를 이용한 데이터 전달
 1) ModelAndView객체를 생성 
 2) Model객체에 데이터를 추가시킨다.(addObject()이용)
 3) 뷰이름을 설정한다.(setViewName()이용)
 
## Chapter2-5. HttpServletRequest를 이용한 데이터 전송

## Chapter2-6. Command 객체 및 @RequestParam를 이용한 데이터 전송

## Chapter2-7. @PathVariable 사용법 및 URL 한글 encoding 처리하기

## Chapter2-8. @PathVariable 활용 방법

## Chapter2-9. 스프링에서 GET 방식과 POST 방식 적용

## Chapter2-10. @MethodAttribute 사용 및 새로운 패키지에 새로운 컨트롤러 추가하기

## Chapter2-11. @MethodAttribute를 이용하여 뷰에 모델 전달하기

## Chapter2-12. @MethodAttribute를 이용하여 커멘드 객체 초기화 하기

<<<<<<< HEAD
## Chapter2-13. redirect: 사용하기 
<<<<<<< HEAD
=======

## Chapter2-14. 폼유효성 검사 처리과정 이해

 [유효성검사]
 Validator : org.springframework.validation.Validator인터페이스
 
  # 구현메소드
   - boolean supports(Class<?> arg0) 
     : Validator가 해당 클래스에 대한 값 검증을 지원하는지 여부를 리턴.
   - void validate(Object target, Errors errors)
     : target객체에 대한 검증을 실행하는 메소드. 
            만약 검증결과 문제가 있을 경우에는 errors 객체에 에러 정보를 저장한다.
   
   ##커맨드 객체에 검증 코드 추가 방법
    - @RequestMapping 어노테이션 메서드에서 커맨드객체 다음 파라미터로 BindingResult타입 이나 Errors타입의 파라미터를 추가한다.
    
    - @RequestMapping 어노테이션 메서드에서 Validator객체를 생성 후, validate()메서드를 호출한다.
       이때 커맨드객체와 BindingResult 또는 Errors 타입의 파라미터를 전달한다.
       
    - Errors.hasErrors()메서드를 이용하면 에러가 있는지 여부를 확인 할 수 있다.
      에러가 있는 경우 true, 없는경우 false를 리턴
      
 
 ## Chapter2-15. Validator 를 이용한 유효성 체크
 
 ## Chapter2-16. ValidationUtils클래스, @Valid, @InitBinder를 이용한 유효성 검사
   
   # ValidateUtils Class
    : validate()메소드를 좀 더 편리하게 사용할 수 있도록 한 클래스
    
    //validate()메소드내에서 처리하는 코드
    String memberName = member.getName();
		if(memberName == null || memberName.trim().isEmpty()){
			System.out.println("Please, input the Name information");
			errors.rejectValue("name", "error is occured when input");
		}
		
    --------> ValidationUtils.rejectIfEmptyOrWhitespace(errors, "name", "error is occured when input");
    
   # @Valid, @InitBinder
    : validate()를 직접 호출하지 않고 스프링 프레임워크에서 호출하는 방법.
    
    1. pom.xml에서 라이브러리를 추가 시켜야 한다.(의존 추가)
	    <dependency>
	    	<groupId>org.hibernate</groupId>               //com.test
	    	<artifactId>hibernate-validator</artifactId>   //mvc
	    	<version>4.2.0.Final</version>
	    </dependency>  
    
    2. @Valid 를 아래와 같이 추가한다.
    	@RequestMapping("/joinOk")
		public String joinOk(@ModelAttribute("model") Member member, BindingResult result){}
		-------->
		@RequestMapping("/joinOk")
		public String joinOk(@ModelAttribute("model") @Valid Member member, BindingResult result){
		
    3. @InitBind 를 아래와 같이 추가한다.
        MemberValidator memberValidator = new MemberValidator();
		memberValidator.validate(member, result);
		-------->
		@InitBind
		protected void initBinder(WebDataBinder binder){
			binder.setValidator(new MemberValidator());
		}
		
## Chapter2-17. Errors , BindingResult 인터페이스
 
  #Errors인터페이스
   : org.springFramework.validation.Errors
   : 유효성 검증 결과를 저장할 때 사용
   <Errors인터페이스 메소드 (반환타입 void)>
    .reject(String errorCode) 
     ->전 객체에 대한 글로벌 에러코드를 추가
    .reject(String errorCode, String defaultMessage)
     ->전 객체에 대한 글로벌 에러코드를 추가하고,
            에러코드에 대한 메세지가 존재하지 않을 경우 디폴트 메세지를 사용한다.
    .reject(String errorCode, Object[] errorArgs, String defaultMessage)
     ->전 객체에 대한 글로벌 에러코드를 추가하고,
            메세지 인자로 errorArgs를 전달하고,
            에러코드에 대한 메세지가 존재하지 않을 경우 디폴트 메세지를 사용한다.
            
    .rejectValue(String field, String errorCode)
     ->필드에 대한 에러코드를 추가
    .rejectValue(String field, String errorCode, String defaultMessage)
     ->필드에 대한 에러코드를 추가
            에러코드에 대한 메세지가 존재하지 않을 경우 디폴트 메세지를 사용한다.
    .rejectValue(String field, String errorCode, Object[] errorArgs, String defaultMessage)
     ->필드에 대한 에러코드를 추가
            메세지 인자로 errorArgs를 전달하고,
            에러코드에 대한 메세지가 존재하지 않을 경우 디폴트 메세지를 사용한다.
    
    --=======================================        
    --Error인터페이스의 에러발생여부 확인하기 위한 메서드
    --=======================================
    .boolean hasErrors()
     --->에러가 존재하는 경우 true리턴 
    .int getErrorCount()
     --->에러개수를 리턴
    .boolean hasGlobalErrors
     --->reject()메소드를 이용해서 추가된 글로벌 에러가 존재할 경우 true리턴
    .int getGlobalErrorCount() 
     --->reject()메소드를 이용해서 추가된 글로벌 에러개수를 리턴
    .boolean hasFieldErrors()
     --->rejectValue() 메소드를 이용해서 추가된 에러가 존재할 경우 true리턴.
    .int getFieldErrorCount()  
     --->rejectValue() 메소드를 이용해서 추가된 에러개수를 리턴 
    .boolean hasFieldErrors(String field)
     --->rejectValue() 메소드를 이용해서 추가된 특정필드의 에러가 존재할 경우 true리턴.
    .int getFieldErrorCount(String field)  
     --->rejectValue() 메소드를 이용해서 추가된 특정필드의 에러개수를 리턴 
     
  #BindingResult
   : org.springFramework.validation.BindingResult 
   : Errors의 하위 인터페이스로 서 폼 값을 커맨드 객체에 바인딩한 결과를 저장하고 에러코드로 부터 에러 메세지를 가져온다.		
=======
=======


 ##Chapter2-18. @Component의 이해
 
  #@Component
  
  @Controller는 @Component를 상속받았다. 
  
  servlet-context.xml에서
  <context:component-scan base-package="" /> 태그를 사용해서 스프링이 클래스(컴포넌트, 컨트롤러)를 검색할 패키지를 지정
  <context:component-scan base-package="" /> 태그는 base-package에서 지정한 패키지에서 @Component가 적용된 클래스를
                                                                               검색해서 빈으로 자동 등록한다.
    따라서 XML설정파일이 다양한 빈 정보를 추가하지 않아도 된다.
    *설정파일에서는 <context:annotaion-config>태그를 사용한다.
    
  @Component("service01")
  public class AbstractSvcImpl implements AbstractSvcImpl{
  	private String name = "01";
  	
  	@Override
  	public String getClassName(){
  		return "AbstractSvcImpl - " + name; 
  	}
  }
  
  설정파일에서 <bean>태그로 작성한다면
  <bean id="service01" class="com.spring.annotationEx.AbstractSvcImpl" />와 같은 방법이다.
  
## Chapter2-19. @Resource, AbstractController 인터페이스

 @Resource
  자바6 및 JEE5에 추가되었다.
  어플리케이션에서 필요로 하는 자원을 자동으로 연결할 때 사용한다. 스프링2.5부터 지원하는 어노테이션.
  의존하는 빈 객체를 전달할 때 사용.
  설정파일에서는 
  <context:annotation-config>태그를 사용해야 한다.
  또는
  <bean Class="org.springframework.beans.factory.annotation.CommonAnnotationBeanPostProcessor" />
  클래스를 빈으로 등록시켜 사용하는 방법이 있다.

## Chapter2-20. @AutoWired, @Qualifier

 [@AutoWired]
 - 의존관계가 자동으로 설정(type기반)
 - 생성자, 필드, 메소드에 적용 가능
 - set계열의 메소드가 아닌 메소드에도 적용이 가능

>>>>>>> refs/remotes/origin/master
 
>>>>>>> refs/remotes/origin/master

